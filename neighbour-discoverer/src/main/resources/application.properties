# ------------------------
# Database configuration
# ------------------------
spring.datasource.url=jdbc:postgresql://localhost:7070/federation
spring.datasource.username= federation
spring.datasource.password= federation
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect
spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = false
# use create-drop for testing; wipes the database when the application is stopped.
# update for more stable, none for production.
spring.jpa.hibernate.ddl-auto = update

# logging
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n
logging.level.org.hibernate.SQL=warn

# Don't start neighbour discoverer as tomcat server.
spring.main.web-application-type= NONE


spring.main.allow-bean-definition-overriding=true


# --------------------------
# DNS facade configuration
# --------------------------
dns.lookup.domain.name = itsinterchange.eu
control.channel.portnr = 8080
message.channel.portnr = 5672
dns.type = prod


# ------------------------------------
# Neighbour Discoverer configuration
# ------------------------------------
# interchange.node-provider.name: the domain name of this interchange node.
# paths.capabilities-exchange: the path for capabilities exchange with remote node.
# paths.subscription-request: the path for subscription request to remote node.
# dns.lookup.interval : How often should be ask the DNS facade for new interchanges
# dns.lookup.initial-delay : When, after startup, should we start checking for new interchanges
# neighbour.capabilities.update-interval : How often we should check for neighbours for capability exchange.
# neighbour.capabilities.initial-delay : When, after startup, should we start checking for neighbours for capability exchange.
# neighbour.subscription-request.update-interval : How often we should check for neighbours we can post subscription requests to.
# neighbour.subscription-request.initial-delay : When, after startup, should we start checking for new neighbours for subscription exchange.
# custom.rest.connection.connection-request-timeout : when our post or get should time out if we receive no answer.
interchange.node-provider.name = bouvet
path.capabilities-exchange = /capabilities
path.subscription-request = /subscription
dns.lookup.interval = 15000
dns.lookup.initial-delay = 5000
neighbour.capabilities.update-interval = 15000
neighbour.capabilities.initial-delay = 10000
neighbour.subscription-request.update-interval = 15000
neighbour.subscription-request.initial-delay = 10000
custom.rest.connection.connection-request-timeout = 10000

# ----------------------
# Subscription polling
# ----------------------
neighbour.subscription-polling.number-of-attempts = 7


# -------------------------------------
# Exponential Backoff configuration.
# -------------------------------------
# Start-interval-length: How long the wait time is between the two first post attempts.
#                        Is multiplied with an exponent as number of attempts increases.
# Number-of-attempts: maximum number we attempt to post to our neighbour.
# Check-interval: Check for neighbours for subscription or capability backoff with 30 seconds delay.
# Check-offset: When, after startup, we start checking for neighbours to perform graceful backoff with.
# Random-shift: a random amount of millis between 0 and 60000(1 min) that the exponential backoff
#               is shifted to prevent collisions.
neighbour.graceful-backoff.start-interval-length = 2000
neighbour.graceful-backoff.number-of-attempts = 4
neighbour.graceful-backoff.check-interval = 30000
neighbour.graceful-backoff.check-offset = 60000
neighbour.graceful-backoff.random-shift = 60000


neighbour.ssl.trust-store-type=JKS
neighbour.ssl.key-store-type=PKCS12
